/*****************************************************************
Датчик APDS-9960 для определения жестов, цвета RGB, приближения и яркости света
http://iarduino.ru/shop/Sensory-Datchiki/datchik-zhestov-osveschennosti-i-cveta-apds-9960.html
Данный скетч определяет яркость света и яркость каждого канала RGB
******************************************************************

ПОДКЛЮЧЕНИЕ ДАТЧИКА:

 Arduino | APDS-9960 | Назначение вывода
 --------+-----------+---------------------------------
   3.3V  |  VCC      | Напряжение питания
 --------+-----------+---------------------------------
   GND   |  GND      | Земля
 --------+-----------+---------------------------------
    A4   |  SDA      | Линия данных шины I2C
 --------+-----------+---------------------------------
    A5   |  SCL      | Линия тактирования шины I2C 
 --------+-----------+---------------------------------
    D2   |  INT      | Выход прерывания (активный уровень «0»)

ВАЖНО:      У датчика APDS-9960 логика и питание только 3,3 В
*****************************************************************/

// Подключаем библиотеки:                                       //
#include <Wire.h>                                               // Для работы с шиной I2C
#include <SparkFun_APDS9960.h>                                  // Для работы с датчиком APDS-9960
SparkFun_APDS9960 apds = SparkFun_APDS9960();                   // Определяем объект apds, экземпляр класса SparkFun_APDS9960
                                                                //
// Объявляем выводы, флаги и функции для прерываний:            //
uint8_t  pinINT = 2;                                            // Определяем № вывода Arduino к которому подключен вывод INT датчика
uint8_t  numINT;                                                // Объявляем переменную для хранения № внешнего прерывания для вывода pinINT
bool     flgINT;                                                // Объявляем флаг указывающий на то, что сработало прерывание
void     funINT(void){flgINT=1;}                                // Определяем функцию, которая будет устанавливать флаг flgINT при каждом её вызове
                                                                //
// Объявляем переменные:                                        //
uint16_t lightAmbient = 0;                                      // Определяем переменную для хранения освещённости общей            в люксах
uint16_t lightRed     = 0;                                      // Определяем переменную для хранения освещённости красного спектра в люксах
uint16_t lightGreen   = 0;                                      // Определяем переменную для хранения освещённости зелёного спектра в люксах
uint16_t lightBlue    = 0;                                      // Определяем переменную для хранения освещённости синего   спектра в люксах
uint16_t lightIntHigh = 1000;                                   // Определяем переменную для хранения верхнего порога освещённости, ниже которого прерывания выводиться не будут
uint16_t lightIntLow  = 50;                                     // Определяем переменную для хранения нижнего  порога освещённости, выше которого прерывания выводиться не будут
                                                                //
void setup() {                                                  //
    Serial.begin(9600);                                         // Инициируем передачу данных в монитор последовательного порта на скорости 9600 бит/сек
//  Подготавливаем переменные и функции для прерываний:         //
    pinMode(pinINT, INPUT);                                     // Переводим вывод pinINT в режим входа
    numINT = digitalPinToInterrupt(pinINT);                     // Определяем № внешнего прерывания для вывода pinINT
    attachInterrupt(numINT, funINT, FALLING);                   // Задаём функцию funINT для обработки прерывания numINT. FALLING значит, что функция funINT будет вызываться при каждом спаде уровня сигнала на выводе pinINT с «1» в «0».
    if(numINT>=0){                                              // Если у вывода pinINT есть внешнее прерывание, то ...
          Serial.println("Pin interrupt OK!");                  // Выводим сообщение об успешном выборе вывода прерывания
    }else{Serial.println("Pin interrupt ERROR!");}              // Иначе, выводим сообщение об ошибке выбранного вывода прерывания
                                                                //
//  Инициируем работу датчика:                                  // 
    if(apds.init()){                                            // Если инициализация прошла успешно, то ...
          Serial.println("Initialization OK!");                 // Выводим сообщение об успешной инициализации датчика
    }else{Serial.println("Initialization ERROR!");}             // Иначе, выводим сообщение об ошибке инициализации датчика
                                                                //
//  Устанавливаем нижний порог срабатывания прерываний:         // Значения освещённости выше данного порога не будут приводить к возникновению прерываний на выводе INT
    if(apds.setLightIntLowThreshold(lightIntLow)){              // Если установлен нижний порог прерываний, то ...
          Serial.println("Set threshold low OK!");              // Выводим сообщение об успешной установке нижнего порога
    }else{Serial.println("Set threshold low ERROR!");}          // Иначе, выводим сообщение об ошибке при установке нижнего порога
                                                                // Прочитать нижний установленный порог можно так: int i; bool j = apds.getLightIntLowThreshold(i); // в переменную i запишется порог, а в переменную j результат выполнения чтения (true/false)
//  Устанавливаем верхний порог срабатывания прерываний:        // Значения освещённости ниже данного порога не будут приводить к возникновению прерываний на выводе INT
    if(apds.setLightIntHighThreshold(lightIntHigh)){            // Если установлен верхний порог прерываний, то ...
          Serial.println("Set threshold high OK!");             // Выводим сообщение об успешной установке верхнего порога
    }else{Serial.println("Set threshold high ERROR!");}         // Иначе, выводим сообщение об ошибке при установке верхнего порога
                                                                // Прочитать верхний установленный порог можно так: int i; bool j = apds.getLightIntHighThreshold(i); // в переменную i запишется порог, а в переменную j результат выполнения чтения (true/false)
//  Разрешаем режим определения освещённости:                   //
    if(apds.enableLightSensor(true)){                           // Если режим определения освещённости запущен (true - c прерываниями на выходе INT), то ...
          Serial.println("Start light sensor OK!");             // Выводим сообщение об успешном запуске режима определения освещённости
    }else{Serial.println("Start light sensor ERROR!");}         // Иначе, выводим сообщение об ошибке запуска режима определения освещённости
                                                                // Запретить режим определения освещённости можно так: bool j = apds.disableLightSensor(); // в переменную j сохранится результат выполнения функции (true/false)
//  Запрет или разрешение прерываний от датчика освещённости:   //
//              apds.setAmbientLightIntEnable(false);           // Запрет     разрешённых ранее прерываний от датчика освещённости. Данная функция, как и представленные выше, так же возвращает true при успехе и false при неудаче
//              apds.setAmbientLightIntEnable(true);            // Разрешение запрещённых ранее прерываний от датчика освещённости. Данная функция, как и представленные выше, так же возвращает true при успехе и false при неудаче
//  uint8_t i = apds.getAmbientLightIntEnable();                // Чтение     разрешены ли прерывания от датчика освещённости. В переменную i запишется значение 0 или 1
                                                                //
//  Ждём завершение инициализации и калибровки:                 //
    delay(500);                                                 //
}                                                               //
                                                                //
void loop(){                                                    //
    if(flgINT){ flgINT=0;                                       // Если установлен флаг flgINT (указывающий о том, что сработало прерывание), то сбрасываем его и ...
//  Читаем значения освещённости в переменные:                  //
        if(apds.readAmbientLight (lightAmbient)                 // Если прочитано значение общей освещённости
        && apds.readRedLight     (lightRed)                     // И    прочитано значение освещённости красного спектра, и
        && apds.readGreenLight   (lightGreen)                   // И    прочитано значение освещённости зелёного спектра, и
        && apds.readBlueLight    (lightBlue)   ){               // И    прочитано значение освещённости синего   спектра, то ...
              Serial.println((String) "Ambient=" + lightAmbient + ", Red=" + lightRed + ", Green=" + lightGreen + ", Blue=" + lightBlue + " lx"); // Выводим все прочитанные значения
        }else{Serial.println("Read light ERROR!");}             // Иначе, выводим сообщение об ошибке чтения освещённости
//      Сообщаем модулю, сбросить прерывание с выхода INT:      //
        if(!apds.clearAmbientLightInt()){                       // Если модуль НЕ сбросил прерывание с выхода INT после его установки как реакцию на освещённость, то ...
              Serial.println("Сlearing interrupt ERROR!");      // Выводим сообщение о том, что прерывание не сброшено
        }                                                       //
    }                                                           //
}                                                               //
