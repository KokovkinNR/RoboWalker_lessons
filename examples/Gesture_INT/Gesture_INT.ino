/*****************************************************************
Датчик APDS-9960 для определения жестов, цвета RGB, приближения и яркости света
http://iarduino.ru/shop/Sensory-Datchiki/datchik-zhestov-osveschennosti-i-cveta-apds-9960.html
Данный скетч определяет жесты
******************************************************************

- UP    Проведите рукой перед датчиком ВПЕРЁД, на расстоянии не более 20 см.
- DOWN  Проведите рукой перед датчиком НАЗАД , на расстоянии не более 20 см.
- LEFT  Проведите рукой перед датчиком ВЛЕВО , на расстоянии не более 20 см.
- RIGHT Проведите рукой перед датчиком ВПРАВО, на расстоянии не более 20 см.
- NEAR  Приближение руки К датчику. (Плавно приблизьте руку к датчику сверху на расстояние ≈ 5 см., задержите её не менее чем на 1 секунду и быстро уберите в любую сторону).
- FAR   Удаление руки ОТ датчика. (Быстро приблизьте руку к датчику с любой стороны, на расстояние ≈ 5 см., задержите её не менее чем на 1 секунду и плавно уберите от датчика вверх на расстояние более 20 см.).
- NONE  Датчик зафиксировал движение, но не смог его распознать.

ПОДКЛЮЧЕНИЕ ДАТЧИКА:

 Arduino | APDS-9960 | Назначение вывода
 --------+-----------+---------------------------------
   3.3V  |  VCC      | Напряжение питания
 --------+-----------+---------------------------------
   GND   |  GND      | Земля
 --------+-----------+---------------------------------
    A4   |  SDA      | Линия данных шины I2C
 --------+-----------+---------------------------------
    A5   |  SCL      | Линия тактирования шины I2C 
 --------+-----------+---------------------------------
    D2   |  INT      | Выход прерывания (активный уровень «0»)

ВАЖНО:      У датчика APDS-9960 логика и питание только 3,3 В
ПРИМЕЧАНИЕ: Расстояние зависит от чувствительности которую можно менять, задавая коэффициент усиления приёмника (setGestureGain) и силу тока драйвера ИК-светодиода (setGestureLEDDrive), см. комментарии в скетче.
            Если Вы хотите знать, находится ли рука в зоне действия механихма обнаружения жестов, подключите светодиод к выводу INT (катод к INT, анод к 3.3V),

*****************************************************************/

// Подключаем библиотеки:                                       //
#include <Wire.h>                                               // Для работы с шиной I2C
#include <SparkFun_APDS9960.h>                                  // Для работы с датчиком APDS-9960
SparkFun_APDS9960 apds = SparkFun_APDS9960();                   // Определяем объект apds, экземпляр класса SparkFun_APDS9960
                                                                //
// Объявляем выводы, флаги и функции для прерываний:            //
uint8_t pinINT = 2;                                             // Определяем № вывода Arduino к которому подключен вывод INT датчика
uint8_t numINT;                                                 // Объявляем переменную для хранения № внешнего прерывания для вывода pinINT
bool    flgINT;                                                 // Объявляем флаг указывающий на то, что сработало прерывание
void    funINT(void){flgINT=1;}                                 // Определяем функцию, которая будет устанавливать флаг flgINT при каждом её вызове
                                                                //
void setup(){                                                   //
    Serial.begin(9600);                                         // Инициируем передачу данных в монитор последовательного порта на скорости 9600 бит/сек
//  Подготавливаем переменные и функции для прерываний:         //
    pinMode(pinINT, INPUT);                                     // Переводим вывод pinINT в режим входа
    numINT = digitalPinToInterrupt(pinINT);                     // Определяем № внешнего прерывания для вывода pinINT
    attachInterrupt(numINT, funINT, FALLING);                   // Задаём функцию funINT для обработки прерывания numINT. FALLING значит, что функция funINT будет вызываться при каждом спаде уровня сигнала на выводе pinINT с «1» в «0».
    if(numINT>=0){                                              // Если у вывода pinINT есть внешнее прерывание, то ...
          Serial.println("Pin interrupt OK!");                  // Выводим сообщение об успешном выборе вывода прерывания
    }else{Serial.println("Pin interrupt ERROR!");}              // Иначе, выводим сообщение об ошибке выбранного вывода прерывания
                                                                //
//  Инициируем работу датчика:                                  // 
    if(apds.init()){                                            // Если инициализация прошла успешно, то ...
          Serial.println("Initialization OK!");                 // Выводим сообщение об успешной инициализации датчика
    }else{Serial.println("Initialization ERROR!");}             // Иначе, выводим сообщение об ошибке инициализации датчика
                                                                //
//  Устанавливаем коэффициент усиления приёмника:               // Доступные значения: 1х, 2х, 4х, 8х (GGAIN_1X, GGAIN_2X, GGAIN_4X, GGAIN_8X). Чем выше коэффициент тем выше чувствительность
    if(apds.setGestureGain(GGAIN_2X)){                          // Если установлен коэффициент усиления приёмника в режиме обнаружения жестов, то ... 
          Serial.println("Set gain OK!");                       // Выводим сообщение об успешной установке коэффициента усиления приёмника
    }else{Serial.println("Set gain ERROR!");}                   // Иначе, выводим сообщение об ошибке при установке коэффициента усиления приёмника
                                                                // Прочитать установленный коэффициент усиления приёмника можно так: uint8_t i = apds.getGestureGain(); // в переменную i сохранится значение: GGAIN_1X, или GGAIN_2X, или GGAIN_4X, или GGAIN_8X
//  Устанавливаем силу тока драйвера ИК-светодиода:             // Доступные значения: 100мА, 50мА, 25мА, 12.5мА (LED_DRIVE_100MA, LED_DRIVE_50MA, LED_DRIVE_25MA, LED_DRIVE_12_5MA). Чем выше сила тока, тем выше чувствительность.
    if(apds.setGestureLEDDrive(LED_DRIVE_100MA)){               // Если устанавлена сила тока драйвера (яркость) ИК-светодиода для обнаружения жестов, то ...
          Serial.println("Set LED drive OK!");                  // Выводим сообщение об успешной установке силы тока драйвера
    }else{Serial.println("Set LED drive ERROR!");}              // Иначе, выводим сообщение об ошибке при установке силы тока драйвера
                                                                // Прочитать установленную силу тока можно так: uint8_t i = apds.getGestureLEDDrive(); // в переменную i сохранится значение: LED_DRIVE_100MA, или LED_DRIVE_50MA, или LED_DRIVE_25MA, или LED_DRIVE_12_5MA
//  Разрешаем режим обнаружение жестов:                         //
    if(apds.enableGestureSensor(true)){                         // Если механизм обнаружения жестов (true - с прерыванием на выходе INT) запущен, то ...
          Serial.println("Start gesture sensor OK!");           // Выводим сообщение об успешном запуске механизма обнаружения жестов
    }else{Serial.println("Start gesture sensor ERROR!");}       // Иначе, выводим сообщение об ошибке запуска механизма обнаружения жестов
                                                                // Запретить работу механизма обнаружения жестов можно так: bool j = apds.disableGestureSensor(); // в переменную j сохранится результат выполнения функции (true/false)
//  Запрет или разрешение прерываний при обнаружении жестов:    //
//              apds.setGestureIntEnable(false);                // Запрет     разрешённых ранее прерываний от механизма обнаружения жестов. Данная функция, как и представленные выше, так же возвращает true при успехе и false при неудаче
//              apds.setGestureIntEnable(true);                 // Разрешение запрещённых ранее прерываний от механизма обнаружения жестов. Данная функция, как и представленные выше, так же возвращает true при успехе и false при неудаче
//  uint8_t i = apds.getGestureIntEnable();                     // Чтение     разрешены ли прерывания от механизма обнаружения жестов. В переменную i запишется значение 0 или 1
                                                                //
//  Ждём завершение инициализации и калибровки:                 //
    delay(500);                                                 //
}                                                               //
                                                                //
void loop(){                                                    //
//  Выводим название зафиксированного жеста:                    //
    if(flgINT){ flgINT=0;                                       // Если установлен флаг flgINT (указывающий о том, что сработало прерывание), то сбрасываем его и ...
        if(apds.isGestureAvailable()){                          // Если зафиксировано движение, то ...
            switch(apds.readGesture()){                         // Сверяем значение соответствующее жесту ...
                case DIR_UP:    Serial.println("UP"   ); break; // Зафиксировано движение вперёд или вверх (зависит от положения датчика)
                case DIR_DOWN:  Serial.println("DOWN" ); break; // Зафиксировано движение назад или вниз (зависит от положения датчика)
                case DIR_LEFT:  Serial.println("LEFT" ); break; // Зафиксировано движение влево
                case DIR_RIGHT: Serial.println("RIGHT"); break; // Зафиксировано движение вправо
                case DIR_NEAR:  Serial.println("NEAR" ); break; // Зафиксировано движение к датчику
                case DIR_FAR:   Serial.println("FAR"  ); break; // Зафиксировано движение от датчика
                default:        Serial.println("NONE" ); break; // Зафиксировано движение, но жест не опознан
            }                                                   //
        }                                                       //
    }                                                           //
}                                                               //
