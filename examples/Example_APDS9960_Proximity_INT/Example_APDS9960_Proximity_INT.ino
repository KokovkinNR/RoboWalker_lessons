/*****************************************************************
Датчик APDS-9960 для определения жестов, цвета RGB, приближения и яркости света
http://iarduino.ru/shop/Sensory-Datchiki/datchik-zhestov-osveschennosti-i-cveta-apds-9960.html
Данный скетч определяет приближение
******************************************************************

ПОДКЛЮЧЕНИЕ ДАТЧИКА:

 Arduino | APDS-9960 | Назначение вывода
 --------+-----------+---------------------------------
   3.3V  |  VCC      | Напряжение питания
 --------+-----------+---------------------------------
   GND   |  GND      | Земля
 --------+-----------+---------------------------------
    A4   |  SDA      | Линия данных шины I2C
 --------+-----------+---------------------------------
    A5   |  SCL      | Линия тактирования шины I2C 
 --------+-----------+---------------------------------
    D2   |  INT      | Выход прерывания (активный уровень «0»)

ВАЖНО:      У датчика APDS-9960 логика и питание только 3,3 В

*****************************************************************/

// Подключаем библиотеки:                                       //
#include <Wire.h>                                               // Для работы с шиной I2C
#include <SparkFun_APDS9960.h>                                  // Для работы с датчиком APDS-9960
SparkFun_APDS9960 apds = SparkFun_APDS9960();                   // Определяем объект apds, экземпляр класса SparkFun_APDS9960
                                                                //
// Объявляем выводы, флаги и функции для прерываний:            //
uint8_t  pinINT = 2;                                            // Определяем № вывода Arduino к которому подключен вывод INT датчика
uint8_t  numINT;                                                // Объявляем переменную для хранения № внешнего прерывания для вывода pinINT
bool     flgINT;                                                // Объявляем флаг указывающий на то, что сработало прерывание
void     funINT(void){flgINT=1;}                                // Определяем функцию, которая будет устанавливать флаг flgINT при каждом её вызове
                                                                //
// Объявляем переменные:                                        //
uint16_t proximityIntHigh = 50;                                 // Определяем переменную для хранения верхнего порога приближения, ниже которого прерывания выводиться не будут
uint16_t proximityIntLow  = 0;                                  // Определяем переменную для хранения нижнего  порога приближения, выше которого прерывания выводиться не будут
uint8_t  proximityData    = 0;                                  // Определяем переменную для хранения значения приближения
                                                                //
void setup() {                                                  //
    Serial.begin(9600);                                         // Инициируем передачу данных в монитор последовательного порта на скорости 9600 бит/сек
//  Подготавливаем переменные и функции для прерываний:         //
    pinMode(pinINT, INPUT);                                     // Переводим вывод pinINT в режим входа
    numINT = digitalPinToInterrupt(pinINT);                     // Определяем № внешнего прерывания для вывода pinINT
    attachInterrupt(numINT, funINT, FALLING);                   // Задаём функцию funINT для обработки прерывания numINT. FALLING значит, что функция funINT будет вызываться при каждом спаде уровня сигнала на выводе pinINT с «1» в «0».
    if(numINT>=0){                                              // Если у вывода pinINT есть внешнее прерывание, то ...
          Serial.println("Pin interrupt OK!");                  // Выводим сообщение об успешном выборе вывода прерывания
    }else{Serial.println("Pin interrupt ERROR!");}              // Иначе, выводим сообщение об ошибке выбранного вывода прерывания
                                                                //
//  Инициируем работу датчика:                                  // 
    if(apds.init()){                                            // Если инициализация прошла успешно, то ...
          Serial.println("Initialization OK!");                 // Выводим сообщение об успешной инициализации датчика
    }else{Serial.println("Initialization ERROR!");}             // Иначе, выводим сообщение об ошибке инициализации датчика
                                                                //
//  Устанавливаем коэффициент усиления приёмника:               // Доступные значения: 1х, 2х, 4х, 8х (PGAIN_1X, PGAIN_2X, PGAIN_4X, PGAIN_8X). Чем выше коэффициент тем выше чувствительность
    if(apds.setProximityGain(PGAIN_2X)){                        // Если установлен коэффициент усиления приёмника в режиме определения расстояния, то ... 
          Serial.println("Set gain OK!");                       // Выводим сообщение об успешной установке коэффициента усиления приёмника
    }else{Serial.println("Set gain ERROR!");}                   // Иначе, выводим сообщение об ошибке при установке коэффициента усиления приёмника
                                                                // Прочитать установленный коэффициент усиления приёмника можно так: uint8_t i = apds.getProximityGain(); // в переменную i сохранится значение: PGAIN_1X, или PGAIN_2X, или PGAIN_4X, или PGAIN_8X
//  Устанавливаем нижний порог определения приближения:         // Значения приближения выше данного порога не будут приводить к возникновению прерываний на выводе INT
    if(apds.setProximityIntLowThreshold(proximityIntLow)){      // Если установлен нижний порог прерываний, то ...
          Serial.println("Set proximity low OK!");              // Выводим сообщение об успешной установке нижнего порога
    }else{Serial.println("Set proximity low ERROR!");}          // Иначе, выводим сообщение об ошибке при установке нижнего порога
                                                                // Прочитать нижний установленный порог можно так: int i; bool j = apds.getProximityIntLowThreshold(i); // в переменную i запишется порог, а в переменную j результат выполнения чтения (true/false)
//  Устанавливаем верхний порог определения приближения:        // Значения приближения ниже данного порога не будут приводить к возникновению прерываний на выводе INT
    if(apds.setProximityIntHighThreshold(proximityIntHigh)){    // Если установлен верхний порог прерываний, то ...
          Serial.println("Set proximity high OK!");             // Выводим сообщение об успешной установке верхнего порога
    }else{Serial.println("Set proximity high ERROR!");}         // Иначе, выводим сообщение об ошибке при установке верхнего порога
                                                                // Прочитать верхний установленный порог можно так: int i; bool j = apds.getProximityIntHighThreshold(i); // в переменную i запишется порог, а в переменную j результат выполнения чтения (true/false)
//  Разрешаем режим определения приближения:                    //
    if(apds.enableProximitySensor(true)){                       // Если механизм определения приближения (true - c прерыванием на выходе INT) запущен, то ...
          Serial.println("Start proximity sensor OK!");         // Выводим сообщение об успешном запуске механизма определения приближения
    }else{Serial.println("Start proximity sensor ERROR!");}     // Иначе, выводим сообщение об ошибке запуска механизма определения приближения
                                                                // Запретить работу механизма определения приближения можно так: bool j = apds.disableProximitySensor(); // в переменную j сохранится результат выполнения функции (true/false)
//  Запрет или разрешение прерываний при определения приближения//
//              apds.setProximityIntEnable(false);              // Запрет     разрешённых ранее прерываний от механизма определения приближения. Данная функция, как и представленные выше, так же возвращает true при успехе и false при неудаче
//              apds.setProximityIntEnable(true);               // Разрешение запрещённых ранее прерываний от механизма определения приближения. Данная функция, как и представленные выше, так же возвращает true при успехе и false при неудаче
//  uint8_t i = apds.getProximityIntEnable();                   // Чтение     разрешены ли прерывания от механизма определения приближения. В переменную i запишется значение 0 или 1
                                                                //
//  Ждём завершение инициализации и калибровки:                 //
    delay(500);                                                 //
}                                                               //
void loop(){                                                    //
    if(flgINT){ flgINT=0;                                       // Если установлен флаг flgINT (указывающий о том, что сработало прерывание), то сбрасываем его и ...
//  Читаем определённое датчиком значение приближения:          //
        if(apds.readProximity(proximityData)){                  // Если значение приближения корректно прочитано в переменную proximityData, то ..
              Serial.println((String) "Proximity="+proximityData);  // Выводим значение приближения
        }else{Serial.println("Reading proximity value ERROR!");}// Иначе, выводим сообщение об ошибке чтения приближения
//      Сообщаем модулю, сбросить прерывание с выхода INT:      //
        if(!apds.clearProximityInt()){                          // Если модуль НЕ сбросил прерывание с выхода INT после его установки как реакцию на приближение, то ...
              Serial.println("Сlearing interrupt ERROR!");      // Выводим сообщение о том, что прерывание не сброшено
        }                                                       //
    }                                                           //
}                                                               //
